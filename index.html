<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mplace</title>
</head>
<body>
    <div id="position"></div>
    <div id="center-pointer"></div>
    <div id="center-tooltip"></div>
    <div id="map"></div>
    <div id="info">
        Mplace by <a href="https://www.youtube.com/@hino_YT" target="_blank">ヒノ</a> | Sponsored by <a href="https://vps.xserver.ne.jp/game-server/" target="_blank">Xserver</a><br>
    </div>
    <div id="ranking">
        <h2>ランキング</h2>
        <small>
            ブロック設置数
        </small>
        <div id="ranking-list">
            <div class="rank">
                <img src="https://s.namemc.com/2d/skin/face.png?id=12b92a9206470fe2&amp;scale=1" class="headimg">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" fill="currentColor" class="crown"><path d="M200-160v-80h560v80H200Zm0-140-51-321q-2 0-4.5.5t-4.5.5q-25 0-42.5-17.5T80-680q0-25 17.5-42.5T140-740q25 0 42.5 17.5T200-680q0 7-1.5 13t-3.5 11l125 56 125-171q-11-8-18-21t-7-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820q0 15-7 28t-18 21l125 171 125-56q-2-5-3.5-11t-1.5-13q0-25 17.5-42.5T820-740q25 0 42.5 17.5T880-680q0 25-17.5 42.5T820-620q-2 0-4.5-.5t-4.5-.5l-51 321H200Z"></path></svg>
                <div class="details">
                    <h3>siyukatu</h3>
                    <div class="graph">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="zoom-controls">
        <button id="zoom-in"></button>
        <button id="zoom-out"></button>
    </div>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #888;
            color: #333;
            font-family: sans-serif;
            position: fixed;
            top: 0;
            left: 0;
        }
        #position {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 5px 10px;
            /* border: 1px solid #aaa; */
            border-radius: 2.5px;
            font-size: 0.8em;
            color: #fff;
            z-index: 1000;
        }
        #info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 0 5px;
            z-index: 1000;
            font-size: 0.8em;
            color: #fff;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            opacity: 0.7;
            transition: opacity 0.3s ease;
            &:hover {
                opacity: 1.0;
            }
            > a {
                color: currentColor;
                text-decoration: underline;
            }
        }
        #ranking {
            position: fixed;
            top: 0;
            right: 0;
            background: rgba(0,0,0,0.65);
            box-shadow: 0 0 10px #0005;
            color: #fff;
            box-sizing: border-box;
            width: 300px;
            height: 100%;
            padding: 10px 12.5px;
            > h2 {
                all: unset;
                font-size: 1.1em;
                display: block;
            }
            > small {
                font-size: 0.8em;
                display: flex;
                gap: 0.5px;
            }
            > #ranking-list {
                > .rank {
                    position: relative;
                    margin-top: 5px;
                    display: flex;
                    padding: 7.5px;
                    background: #0007;
                    border-radius: 3px;
                    > .crown {
                        position: absolute;
                        top: -10px;
                        right: 0px;
                        width: 1.5em;
                        height: 1.5em;
                        fill: gold;
                        transform: rotate(15deg);
                    }
                    > .headimg {
                        height: 2.5em;
                        aspect-ratio: 1;
                        image-rendering: pixelated;
                        border: solid 1px #555;
                    }
                    > .details {
                        margin-left: 7.5px;
                        margin-block: 2px;
                        flex-grow: 1;
                        display: flex;
                        flex-direction: column;
                        > h3 {
                            all: unset;
                            display: block;
                            font-size: 0.9em;
                            line-height: 1;
                        }
                        > .graph {
                            display: flex;
                            border-bottom: solid 1px #ccc;
                            margin: 2px 0 0 0;
                            flex-grow: 1;
                            gap: 4px;
                            > .stick {
                                background: #fff;
                                width: 100%;
                                margin-top: auto;
                            }
                        }
                    }
                }
            }
        }
        #zoom-controls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            z-index: 1001;
            background: rgba(0,0,0,0.75);
            overflow: hidden;
            > button {
                all: unset;
                position: relative;
                width: 2.5em;
                height: 2.5em;
                cursor: pointer;
                display: flex;
                box-shadow: 0 0 5px rgba(0,0,0,0.3);
                transition: background 0.3s ease;
                &:hover {
                    background: rgba(255,255,255,0.1);
                }
            }
            #zoom-in {
                &::before, &::after {
                    content: '';
                    position: absolute;
                    background: #fff;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 1em;
                    height: 0.225em;
                }
                &::after {
                    width: 0.225em;
                    height: 1em;
                }
            }
            #zoom-out {
                &::before {
                    content: '';
                    position: absolute;
                    background: #fff;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 1em;
                    height: 0.225em;
                }
            }
        }
        #center-pointer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1002;
            display: none;
        }
        #center-pointer::before,
        #center-pointer::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.3);
        }
        #center-pointer::before {
            top: 50%;
            left: 8px;
            right: 8px;
            height: 2px;
            transform: translateY(-50%);
        }
        #center-pointer::after {
            left: 50%;
            top: 8px;
            bottom: 8px;
            width: 2px;
            transform: translateX(-50%);
        }
        #center-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -120%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1003;
            display: none;
        }
        #map {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            user-select: none;
            width: 0;
            height: 0;
            overflow: visible;
            > .chunk {
                position: absolute;
                width: 128px;
                height: 128px;
                display: grid;
                grid-template-columns: repeat(16, 1fr);
                grid-template-rows: repeat(16, 1fr);
                background: #7FB238;
                transition: background-color 0.5s ease;
                &.loading {
                    animation: pulse 1s infinite;
                }
            }
        }
        @keyframes pulse {
            0% { background-color: #d0d0d0; }
            50% { background-color: #ddd; }
            100% { background-color: #d0d0d0; }
        }
    </style>
    <script>
        // 設定定数
        const MIN_ZOOM = 0.25;
        const MAX_ZOOM = 3.5;
        
        let pos = { x: 0, y: 0 };
        let mouse_pos = { x: 0, y: 0 };
        let zoom = 0.5;
        let prev_mouse_pos = null;
        const chunkSize = 16;
        const chunkPixel = 128;
        const loadedChunks = new Map();
        const loadingChunks = new Map(); // key: chunk_key, value: AbortController
        const fetchQueue = [];
        const MAX_CONCURRENT_FETCH = 50;

        // URLハッシュ管理
        function updateURLHash() {
            const hash = `#pos=${Math.round(pos.x)},${Math.round(pos.y)}&zoom=${zoom.toFixed(2)}`;
            if (window.location.hash !== hash) {
                window.history.replaceState(null, null, hash);
            }
        }

        function loadFromURLHash() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                const params = new URLSearchParams(hash);
                const posParam = params.get('pos');
                const zoomParam = params.get('zoom');
                
                if (posParam) {
                    const [x, y] = posParam.split(',').map(Number);
                    if (!isNaN(x) && !isNaN(y)) {
                        pos.x = x;
                        pos.y = y;
                    }
                }
                
                if (zoomParam) {
                    const zoomValue = parseFloat(zoomParam);
                    if (!isNaN(zoomValue) && zoomValue >= MIN_ZOOM && zoomValue <= MAX_ZOOM) {
                        zoom = zoomValue;
                    }
                }
            }
        }

        // 座標表示の更新（変化があった場合のみ）
        let lastDisplayedPosition = null;
        function updatePositionDisplay() {
            const map_pos = { x: 0, y: 0 };
            // チャンク座標系に変換（Minecraft座標）
            map_pos.x = (mouse_pos.x - window.innerWidth / 2 - pos.x) / zoom;
            map_pos.y = (mouse_pos.y - window.innerHeight / 2 - pos.y) / zoom;
            // ピクセル座標をMinecraft座標に変換
            const mc_x = Math.floor(map_pos.x * 16 / chunkPixel);
            const mc_y = Math.floor(map_pos.y * 16 / chunkPixel);
            const zoomRounded = Math.round(zoom * 100) / 100; // 小数点以下2桁で丸める
            
            const currentPosition = `${mc_x},${mc_y}`;
            
            // 前回と同じ内容の場合は更新しない
            if (lastDisplayedPosition !== currentPosition) {
                const position = document.getElementById('position');
                position.innerText = currentPosition;
                lastDisplayedPosition = currentPosition;
            }
        }

        // 画面中央のツールチップ表示
        function showCenterTooltip() {
            const centerPointer = document.getElementById('center-pointer');
            const centerTooltip = document.getElementById('center-tooltip');
            centerPointer.style.display = 'block';
            centerTooltip.style.display = 'block';
            
            // 画面中央の座標を計算
            const centerX = -pos.x / zoom;
            const centerY = -pos.y / zoom;
            const mc_x = Math.floor(centerX * 16 / chunkPixel);
            const mc_y = Math.floor(centerY * 16 / chunkPixel);
            centerTooltip.innerText = `MC: (${mc_x}, ${mc_y})`;
        }

        function hideCenterTooltip() {
            const centerPointer = document.getElementById('center-pointer');
            const centerTooltip = document.getElementById('center-tooltip');
            centerPointer.style.display = 'none';
            centerTooltip.style.display = 'none';
        }

        const colors = {
            WHITE_WOOL: "#F9FFFE",
            ORANGE_WOOL: "#F9801D",
            MAGENTA_WOOL: "#C74EBD",
            LIGHT_BLUE_WOOL: "#3AB3DA",
            YELLOW_WOOL: "#FED83D",
            LIME_WOOL: "#80C71F",
            PINK_WOOL: "#F38BAA",
            GRAY_WOOL: "#474F52",
            LIGHT_GRAY_WOOL: "#9D9D97",
            CYAN_WOOL: "#169C9C",
            PURPLE_WOOL: "#8932B8",
            BLUE_WOOL: "#3C44AA",
            BROWN_WOOL: "#835432",
            GREEN_WOOL: "#5E7C16",
            RED_WOOL: "#B02E26",
            BLACK_WOOL: "#1D1D21",
            WHITE_CONCRETE_POWDER: "#E7E7E7",
            ORANGE_CONCRETE_POWDER: "#F2B07A",
            MAGENTA_CONCRETE_POWDER: "#B95DAF",
            LIGHT_BLUE_CONCRETE_POWDER: "#8395A7",
            YELLOW_CONCRETE_POWDER: "#E7E23A",
            LIME_CONCRETE_POWDER: "#A7E22E",
            PINK_CONCRETE_POWDER: "#E7A7B7",
            GRAY_CONCRETE_POWDER: "#6D6D6D",
            LIGHT_GRAY_CONCRETE_POWDER: "#BFBFBF",
            CYAN_CONCRETE_POWDER: "#4AABAB",
            PURPLE_CONCRETE_POWDER: "#A24D8E",
            BLUE_CONCRETE_POWDER: "#4A6CD4",
            BROWN_CONCRETE_POWDER: "#A87C5A",
            GREEN_CONCRETE_POWDER: "#7CA15C",
            RED_CONCRETE_POWDER: "#D36C6C",
            BLACK_CONCRETE_POWDER: "#2B2B2B",
            WHITE_CONCRETE: "#F4F4F4",
            ORANGE_CONCRETE: "#FFA400",
            MAGENTA_CONCRETE: "#B24CD8",
            LIGHT_BLUE_CONCRETE: "#6699D8",
            YELLOW_CONCRETE: "#FED83D",
            LIME_CONCRETE: "#80C71F",
            PINK_CONCRETE: "#FFB4B4",
            GRAY_CONCRETE: "#474F52",
            LIGHT_GRAY_CONCRETE: "#9D9D97",
            CYAN_CONCRETE: "#169C9C",
            PURPLE_CONCRETE: "#8932B8",
            BLUE_CONCRETE: "#3C44AA",
            BROWN_CONCRETE: "#835432",
            GREEN_CONCRETE: "#5E7C16",
            RED_CONCRETE: "#B02E26",
            BLACK_CONCRETE: "#1D1D21",
            TERRACOTTA: "#A97A65",
            WHITE_TERRACOTTA: "#D1B1A1",
            ORANGE_TERRACOTTA: "#A35422",
            MAGENTA_TERRACOTTA: "#8E3C7B",
            LIGHT_BLUE_TERRACOTTA: "#6C6EA3",
            YELLOW_TERRACOTTA: "#D0A53C",
            LIME_TERRACOTTA: "#5A7A3C",
            PINK_TERRACOTTA: "#B76A7A",
            GRAY_TERRACOTTA: "#4C4842",
            LIGHT_GRAY_TERRACOTTA: "#9D8B7A",
            CYAN_TERRACOTTA: "#4A686A",
            PURPLE_TERRACOTTA: "#7C3F7C",
            BLUE_TERRACOTTA: "#3C3F7C",
            BROWN_TERRACOTTA: "#4C3222",
            GREEN_TERRACOTTA: "#4C7A3C",
            RED_TERRACOTTA: "#8E3C3C",
            BLACK_TERRACOTTA: "#251610",
            BLACK_GLAZED_TERRACOTTA: "#1D1D21",
            BLUE_GLAZED_TERRACOTTA: "#3C44AA",
            BROWN_GLAZED_TERRACOTTA: "#835432",
            CYAN_GLAZED_TERRACOTTA: "#169C9C",
            GRAY_GLAZED_TERRACOTTA: "#474F52",
            GREEN_GLAZED_TERRACOTTA: "#5E7C16",
            LIGHT_BLUE_GLAZED_TERRACOTTA: "#3AB3DA",
            LIGHT_GRAY_GLAZED_TERRACOTTA: "#9D9D97",
            LIME_GLAZED_TERRACOTTA: "#80C71F",
            MAGENTA_GLAZED_TERRACOTTA: "#C74EBD",
            ORANGE_GLAZED_TERRACOTTA: "#F9801D",
            PINK_GLAZED_TERRACOTTA: "#F38BAA",
            PURPLE_GLAZED_TERRACOTTA: "#8932B8",
            RED_GLAZED_TERRACOTTA: "#B02E26",
            WHITE_GLAZED_TERRACOTTA: "#F9FFFE",
            YELLOW_GLAZED_TERRACOTTA: "#FED83D",
        };

        function getVisibleChunkRange() {
            const map = document.getElementById('map');
            const rect = map.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const centerX = vw / 2 - pos.x;
            const centerY = vh / 2 - pos.y;
            const left = (-pos.x - vw / 2) / zoom;
            const top = (-pos.y - vh / 2) / zoom;
            const right = (vw / 2 - pos.x) / zoom;
            const bottom = (vh / 2 - pos.y) / zoom;
            const chunkLeft = Math.floor(left / chunkPixel);
            const chunkRight = Math.floor(right / chunkPixel);
            const chunkTop = Math.floor(top / chunkPixel);
            const chunkBottom = Math.floor(bottom / chunkPixel);
            return {
                left: chunkLeft,
                right: chunkRight,
                top: chunkTop,
                bottom: chunkBottom
            };
        }

        async function loadChunk(x, y, priority = 0) {
            const key = `${x}_${y}`;
            if (loadedChunks.has(key) || loadingChunks.has(key)) return;
            const map = document.getElementById('map');
            const chunkEl = document.createElement('div');
            chunkEl.className = 'chunk loading';
            chunkEl.style.left = `${x * chunkPixel}px`;
            chunkEl.style.top = `${y * chunkPixel}px`;
            chunkEl.dataset.chunk = key;
            map.appendChild(chunkEl);
            loadedChunks.set(key, { element: chunkEl, data: null });
            // 優先度付きでキューに追加
            const chunkData = { key, chunkEl, x, y, retryCount: 0, priority };
            
            // 優先度に基づいて挿入位置を決定
            let insertIndex = fetchQueue.length;
            for (let i = 0; i < fetchQueue.length; i++) {
                if (fetchQueue[i].priority > priority) {
                    insertIndex = i;
                    break;
                }
            }
            fetchQueue.splice(insertIndex, 0, chunkData);
            processFetchQueue();
        }

        async function processFetchQueue() {
            if (loadingChunks.size >= MAX_CONCURRENT_FETCH) return;
            if (fetchQueue.length === 0) return;
            const { key, chunkEl, x, y, retryCount, priority } = fetchQueue.shift();
            
            // AbortController作成
            const abortController = new AbortController();
            loadingChunks.set(key, abortController);
            
            try {
                const res = await fetch(`/mapfiles/${key}.json`, {
                    signal: abortController.signal
                });
                chunkEl.classList.remove('loading');
                let data = null;
                try {
                    data = await res.json();
                } catch (e) {}
                if (data === null) {
                    data = new Array(chunkSize * chunkSize).fill(0);
                }
                const chunkData = loadedChunks.get(key);
                if (chunkData) {
                    chunkData.data = data;
                    for (let by = 0; by < chunkSize; by++) {
                        for (let bx = 0; bx < chunkSize; bx++) {
                            const idx = by * chunkSize + bx;
                            const blockType = data[idx];
                            if (!blockType || blockType === 0) continue;
                            const block = document.createElement('div');
                            block.className = 'block';
                            block.style.gridColumn = bx + 1;
                            block.style.gridRow = by + 1;
                            block.style.background = colors[blockType] || '#7FB238';
                            chunkEl.appendChild(block);
                        }
                    }
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    // abort時は再試行しない
                    if (loadedChunks.has(key)) {
                        chunkEl.remove();
                        loadedChunks.delete(key);
                    }
                } else {
                    // 失敗時は再試行（最大3回）優先度を保持
                    if (retryCount < 3) {
                        fetchQueue.unshift({ key, chunkEl, x, y, retryCount: retryCount + 1, priority });
                    } else {
                        // 最大試行回数に達したら削除
                        chunkEl.remove();
                        loadedChunks.delete(key);
                    }
                }
            } finally {
                loadingChunks.delete(key);
                // 次のfetchを進める
                processFetchQueue();
            }
        }

        function cleanupChunks(visible) {
            for (const [key, value] of loadedChunks.entries()) {
                const [x, y] = key.split('_').map(Number);
                if (x < visible.left || x > visible.right || y < visible.top || y > visible.bottom) {
                    // 読み込み中のfetchをabort
                    if (loadingChunks.has(key)) {
                        loadingChunks.get(key).abort();
                        loadingChunks.delete(key);
                    }
                    // キューからも削除
                    const queueIndex = fetchQueue.findIndex(item => item.key === key);
                    if (queueIndex !== -1) {
                        fetchQueue.splice(queueIndex, 1);
                    }
                    value.element.remove();
                    loadedChunks.delete(key);
                }
            }
        }

        async function update() {
            const map = document.getElementById('map');
            map.style.transform = `translate(calc(-50% + ${pos.x}px), calc(-50% + ${pos.y}px)) scale(${zoom})`;
            // 表示範囲のチャンク計算
            const visible = getVisibleChunkRange();
            
            // 画面中央のチャンク座標計算
            const centerChunkX = Math.floor((-pos.x) / zoom / chunkPixel);
            const centerChunkY = Math.floor((-pos.y) / zoom / chunkPixel);
            
            // 必要なチャンクを中央からの距離順でソート
            const chunksToLoad = [];
            for (let cx = visible.left; cx <= visible.right; cx++) {
                for (let cy = visible.top; cy <= visible.bottom; cy++) {
                    const distance = Math.sqrt(Math.pow(cx - centerChunkX, 2) + Math.pow(cy - centerChunkY, 2));
                    chunksToLoad.push({ x: cx, y: cy, distance: distance });
                }
            }
            
            // 距離順でソート（近いものから優先）
            chunksToLoad.sort((a, b) => a.distance - b.distance);
            
            // ソートされた順序でチャンクをロード（優先度付き）
            for (let i = 0; i < chunksToLoad.length; i++) {
                const chunk = chunksToLoad[i];
                loadChunk(chunk.x, chunk.y, chunk.distance);
            }
            
            // 範囲外チャンク削除
            cleanupChunks(visible);
            requestAnimationFrame(update);
        }
        document.addEventListener('wheel', function(event) {
            event.preventDefault();
            
            // wheel操作中はcentertooltipを表示
            showCenterTooltip();
            
            // トラックパッドのピンチ操作の検出（Ctrl+wheel）
            if (event.ctrlKey) {
                // ピンチズーム操作
                const prev_zoom = zoom;
                const centerScreenX = event.clientX - window.innerWidth / 2;
                const centerScreenY = event.clientY - window.innerHeight / 2;
                const mapX = (centerScreenX - pos.x) / prev_zoom;
                const mapY = (centerScreenY - pos.y) / prev_zoom;
                
                if (event.deltaY < 0) {
                    zoom += event.deltaY * -0.01;
                } else {
                    zoom -= event.deltaY * 0.01;
                }
                if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
                if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
                
                pos.x = centerScreenX - mapX * zoom;
                pos.y = centerScreenY - mapY * zoom;
                updateURLHash();
            } else {
                // 通常のスクロール（移動 + ズーム）
                const prev_zoom = zoom;
                const centerScreenX = event.clientX - window.innerWidth / 2;
                const centerScreenY = event.clientY - window.innerHeight / 2;
                const mapX = (centerScreenX - pos.x) / prev_zoom;
                const mapY = (centerScreenY - pos.y) / prev_zoom;
                
                // 移動処理（deltaX, deltaYを使用）
                pos.x -= event.deltaX * 1;
                pos.y -= event.deltaY * 1;
                
                // Shiftキーでズーム
                if (event.shiftKey) {
                    if (event.deltaY < 0) {
                        zoom += event.deltaY * -0.005;
                    } else {
                        zoom -= event.deltaY * 0.005;
                    }
                    if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
                    if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
                    
                    pos.x = centerScreenX - mapX * zoom;
                    pos.y = centerScreenY - mapY * zoom;
                }
                updateURLHash();
            }
            
            // wheel操作終了の検知のためのタイマー設定
            clearTimeout(this.wheelTimer);
            this.wheelTimer = setTimeout(() => {
                hideCenterTooltip();
            }, 200);
        }, { passive: false });
        // 二本指ズームに対応
        // タッチ用の前回位置保存
        let lastTouchCenter = null;
        let lastTouchDistance = null;

        document.addEventListener('touchstart', function(event) {
            if (event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                lastTouchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                lastTouchCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
        });

        document.addEventListener('touchmove', function(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                hideCenterTooltip();
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const currentCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // 移動処理（2本指の中点の移動）
                if (lastTouchCenter) {
                    const deltaX = currentCenter.x - lastTouchCenter.x;
                    const deltaY = currentCenter.y - lastTouchCenter.y;
                    pos.x += deltaX;
                    pos.y += deltaY;
                }
                
                // ズーム処理（距離変化が閾値を超える場合のみ）
                if (lastTouchDistance && Math.abs(currentDistance - lastTouchDistance) > 2) {
                    const prev_zoom = zoom;
                    // ズーム中心（画面中心からの相対座標）
                    const centerScreenX = currentCenter.x - window.innerWidth / 2;
                    const centerScreenY = currentCenter.y - window.innerHeight / 2;
                    // ズーム前のmap座標（移動後のposを使用）
                    const mapX = (centerScreenX - pos.x) / prev_zoom;
                    const mapY = (centerScreenY - pos.y) / prev_zoom;
                    const deltaDistance = currentDistance - lastTouchDistance;
                    zoom += deltaDistance * 0.008;
                    if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
                    if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
                    // ズーム後も同じmap座標が同じ画面座標になるようにpos調整
                    pos.x = centerScreenX - mapX * zoom;
                    pos.y = centerScreenY - mapY * zoom;
                    
                    // ズーム処理が実行された場合のみlastDistanceを更新
                    lastTouchDistance = currentDistance;
                    updateURLHash();
                }
                
                lastTouchCenter = currentCenter;
                
                // 移動中の中央座標表示
                showCenterTooltip();
                return;
            }

            // 1本指移動
            if (event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0];
                mouse_pos.x = touch.clientX;
                mouse_pos.y = touch.clientY;
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                
                // 移動中の中央座標表示
                showCenterTooltip();
            }
        }, { passive: false });
            document.addEventListener('touchend', function(event) {
                prev_mouse_pos = null;
                lastTouchCenter = null;
                lastTouchDistance = null;
                hideCenterTooltip();
                updateURLHash();
            });
        document.addEventListener('mousemove', function(event) {
            mouse_pos.x = event.clientX;
            mouse_pos.y = event.clientY;
            
            // マウス移動時に座標表示更新
            updatePositionDisplay();
            
            if (event.buttons === 1) {
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                
                // ドラッグ移動中の中央座標表示
                showCenterTooltip();
            } else {
                if (prev_mouse_pos !== null) {
                    // ドラッグ終了時にURL更新
                    updateURLHash();
                }
                prev_mouse_pos = null;
                hideCenterTooltip();
            }
        });
        
        // 初期化時にURLハッシュから状態を復元
        loadFromURLHash();
        
        // 初回起動
        update();
    </script>
</body>
</html>