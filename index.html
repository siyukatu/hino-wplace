<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MC Wplace</title>
</head>
<body>
    <div id="position"></div>
    <div id="map"></div>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #888;
        }
        #position {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            padding: 5px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #map {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            user-select: none;
            > .chunk {
                position: absolute;
                width: 128px;
                height: 128px;
                display: grid;
                grid-template-columns: repeat(16, 1fr);
                grid-template-rows: repeat(16, 1fr);
                background: #ddd;
                transition: background-color 0.5s ease;
                &.loading {
                    animation: pulse 1s infinite;
                }
            }
        }
        @keyframes pulse {
            0% { background-color: #d0d0d0; }
            50% { background-color: #ddd; }
            100% { background-color: #d0d0d0; }
        }
    </style>
    <script>
        let pos = { x: 0, y: 0 };
        let mouse_pos = { x: 0, y: 0 };
        let zoom = 0.5;
        let prev_mouse_pos = null;
        const chunkSize = 16;
        const chunkPixel = 128;
        const loadedChunks = new Map();
        const loadingChunks = new Set(); // リクエスト中管理
        const fetchQueue = [];
        const MAX_CONCURRENT_FETCH = 20;

        const colors = {
            WHITE_WOOL: "#F9FFFE",
            ORANGE_WOOL: "#F9801D",
            MAGENTA_WOOL: "#C74EBD",
            LIGHT_BLUE_WOOL: "#3AB3DA",
            YELLOW_WOOL: "#FED83D",
            LIME_WOOL: "#80C71F",
            PINK_WOOL: "#F38BAA",
            GRAY_WOOL: "#474F52",
            LIGHT_GRAY_WOOL: "#9D9D97",
            CYAN_WOOL: "#169C9C",
            PURPLE_WOOL: "#8932B8",
            BLUE_WOOL: "#3C44AA",
            BROWN_WOOL: "#835432",
            GREEN_WOOL: "#5E7C16",
            RED_WOOL: "#B02E26",
            BLACK_WOOL: "#1D1D21",
            WHITE_CONCRETE_POWDER: "#E7E7E7",
            ORANGE_CONCRETE_POWDER: "#F2B07A",
            MAGENTA_CONCRETE_POWDER: "#B95DAF",
            LIGHT_BLUE_CONCRETE_POWDER: "#8395A7",
            YELLOW_CONCRETE_POWDER: "#E7E23A",
            LIME_CONCRETE_POWDER: "#A7E22E",
            PINK_CONCRETE_POWDER: "#E7A7B7",
            GRAY_CONCRETE_POWDER: "#6D6D6D",
            LIGHT_GRAY_CONCRETE_POWDER: "#BFBFBF",
            CYAN_CONCRETE_POWDER: "#4AABAB",
            PURPLE_CONCRETE_POWDER: "#A24D8E",
            BLUE_CONCRETE_POWDER: "#4A6CD4",
            BROWN_CONCRETE_POWDER: "#A87C5A",
            GREEN_CONCRETE_POWDER: "#7CA15C",
            RED_CONCRETE_POWDER: "#D36C6C",
            BLACK_CONCRETE_POWDER: "#2B2B2B",
            WHITE_CONCRETE: "#F4F4F4",
            ORANGE_CONCRETE: "#FFA400",
            MAGENTA_CONCRETE: "#B24CD8",
            LIGHT_BLUE_CONCRETE: "#6699D8",
            YELLOW_CONCRETE: "#FED83D",
            LIME_CONCRETE: "#80C71F",
            PINK_CONCRETE: "#FFB4B4",
            GRAY_CONCRETE: "#474F52",
            LIGHT_GRAY_CONCRETE: "#9D9D97",
            CYAN_CONCRETE: "#169C9C",
            PURPLE_CONCRETE: "#8932B8",
            BLUE_CONCRETE: "#3C44AA",
            BROWN_CONCRETE: "#835432",
            GREEN_CONCRETE: "#5E7C16",
            RED_CONCRETE: "#B02E26",
            BLACK_CONCRETE: "#1D1D21",
            TERRACOTTA: "#A97A65",
            WHITE_TERRACOTTA: "#D1B1A1",
            ORANGE_TERRACOTTA: "#A35422",
            MAGENTA_TERRACOTTA: "#8E3C7B",
            LIGHT_BLUE_TERRACOTTA: "#6C6EA3",
            YELLOW_TERRACOTTA: "#D0A53C",
            LIME_TERRACOTTA: "#5A7A3C",
            PINK_TERRACOTTA: "#B76A7A",
            GRAY_TERRACOTTA: "#4C4842",
            LIGHT_GRAY_TERRACOTTA: "#9D8B7A",
            CYAN_TERRACOTTA: "#4A686A",
            PURPLE_TERRACOTTA: "#7C3F7C",
            BLUE_TERRACOTTA: "#3C3F7C",
            BROWN_TERRACOTTA: "#4C3222",
            GREEN_TERRACOTTA: "#4C7A3C",
            RED_TERRACOTTA: "#8E3C3C",
            BLACK_TERRACOTTA: "#251610",
            BLACK_GLAZED_TERRACOTTA: "#1D1D21",
            BLUE_GLAZED_TERRACOTTA: "#3C44AA",
            BROWN_GLAZED_TERRACOTTA: "#835432",
            CYAN_GLAZED_TERRACOTTA: "#169C9C",
            GRAY_GLAZED_TERRACOTTA: "#474F52",
            GREEN_GLAZED_TERRACOTTA: "#5E7C16",
            LIGHT_BLUE_GLAZED_TERRACOTTA: "#3AB3DA",
            LIGHT_GRAY_GLAZED_TERRACOTTA: "#9D9D97",
            LIME_GLAZED_TERRACOTTA: "#80C71F",
            MAGENTA_GLAZED_TERRACOTTA: "#C74EBD",
            ORANGE_GLAZED_TERRACOTTA: "#F9801D",
            PINK_GLAZED_TERRACOTTA: "#F38BAA",
            PURPLE_GLAZED_TERRACOTTA: "#8932B8",
            RED_GLAZED_TERRACOTTA: "#B02E26",
            WHITE_GLAZED_TERRACOTTA: "#F9FFFE",
            YELLOW_GLAZED_TERRACOTTA: "#FED83D",
        };

        function getVisibleChunkRange() {
            const map = document.getElementById('map');
            const rect = map.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const centerX = vw / 2 - pos.x;
            const centerY = vh / 2 - pos.y;
            const left = (-pos.x - vw / 2) / zoom;
            const top = (-pos.y - vh / 2) / zoom;
            const right = (vw / 2 - pos.x) / zoom;
            const bottom = (vh / 2 - pos.y) / zoom;
            const chunkLeft = Math.floor(left / chunkPixel);
            const chunkRight = Math.floor(right / chunkPixel);
            const chunkTop = Math.floor(top / chunkPixel);
            const chunkBottom = Math.floor(bottom / chunkPixel);
            return {
                left: chunkLeft,
                right: chunkRight,
                top: chunkTop,
                bottom: chunkBottom
            };
        }

        async function loadChunk(x, y) {
            const key = `${x}_${y}`;
            if (loadedChunks.has(key) || loadingChunks.has(key)) return;
            const map = document.getElementById('map');
            const chunkEl = document.createElement('div');
            chunkEl.className = 'chunk loading';
            chunkEl.style.left = `${x * chunkPixel}px`;
            chunkEl.style.top = `${y * chunkPixel}px`;
            chunkEl.dataset.chunk = key;
            map.appendChild(chunkEl);
            loadedChunks.set(key, { element: chunkEl, data: null });
            // キューに追加
            fetchQueue.push({ key, chunkEl, x, y });
            processFetchQueue();
        }

        async function processFetchQueue() {
            if (loadingChunks.size >= MAX_CONCURRENT_FETCH) return;
            if (fetchQueue.length === 0) return;
            const { key, chunkEl, x, y } = fetchQueue.shift();
            loadingChunks.add(key);
            try {
                const res = await fetch(`/mapfiles/${key}.json`);
                chunkEl.classList.remove('loading');
                let data = null;
                try {
                    data = await res.json();
                } catch (e) {}
                if (data === null) {
                    data = new Array(chunkSize * chunkSize).fill(0);
                }
                loadedChunks.get(key).data = data;
                for (let by = 0; by < chunkSize; by++) {
                    for (let bx = 0; bx < chunkSize; bx++) {
                        const idx = by * chunkSize + bx;
                        const blockType = data[idx];
                        if (!blockType || blockType === 0) continue;
                        const block = document.createElement('div');
                        block.className = 'block';
                        block.style.gridColumn = bx + 1;
                        block.style.gridRow = by + 1;
                        block.style.background = colors[blockType] || '#7FB238';
                        chunkEl.appendChild(block);
                    }
                }
            } catch (e) {
                chunkEl.remove();
                loadedChunks.delete(key);
                // 失敗時は再度キューに入れない（無限ループ防止）
            } finally {
                loadingChunks.delete(key);
                // 次のfetchを進める
                processFetchQueue();
            }
        }
        }

        function cleanupChunks(visible) {
            for (const [key, value] of loadedChunks.entries()) {
                const [x, y] = key.split('_').map(Number);
                if (x < visible.left || x > visible.right || y < visible.top || y > visible.bottom) {
                    value.element.remove();
                    loadedChunks.delete(key);
                }
            }
        }

        async function update() {
            const map = document.getElementById('map');
            map.style.transform = `translate(calc(-50% + ${pos.x}px), calc(-50% + ${pos.y}px)) scale(${zoom})`;
            // 表示範囲のチャンク計算
            const visible = getVisibleChunkRange();
            // 必要なチャンクだけ描画・fetch
            for (let cx = visible.left; cx <= visible.right; cx++) {
                for (let cy = visible.top; cy <= visible.bottom; cy++) {
                    loadChunk(cx, cy);
                }
            }
            // 範囲外チャンク削除
            cleanupChunks(visible);
            requestAnimationFrame(update);
        }
        document.addEventListener('wheel', function(event) {
            event.preventDefault();
            const map = document.getElementById('map');
            const rect = map.getBoundingClientRect();
            // マウス座標をmap要素のtransform前の座標系に変換
            const mouse_x = (event.clientX - rect.left - pos.x) / zoom;
            const mouse_y = (event.clientY - rect.top - pos.y) / zoom;
            // 現在のズーム前の値
            const prev_zoom = zoom;
            if (event.deltaY < 0) {
                zoom += event.deltaY * -0.005;
            } else {
                zoom -= event.deltaY * 0.005;
            }
            if (zoom < 0.1) zoom = 0.1;
            if (zoom > 10) zoom = 10;
            // ズーム後、マウス位置が同じmap内の点を指すようにposを調整
            pos.x = event.clientX - rect.left - mouse_x * zoom;
            pos.y = event.clientY - rect.top - mouse_y * zoom;
                // update()はrequestAnimationFrameで自動呼び出しされるので不要
        }, { passive: false });
        // 二本指ズームに対応
        document.addEventListener('touchmove', function(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                const map = document.getElementById('map');
                const rect = map.getBoundingClientRect();
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                if (this.lastDistance) {
                    const deltaDistance = currentDistance - this.lastDistance;
                    const mouse_x = ( (touch1.clientX + touch2.clientX) / 2 - rect.left - pos.x ) / zoom;
                    const mouse_y = ( (touch1.clientY + touch2.clientY) / 2 - rect.top - pos.y ) / zoom;
                    const prev_zoom = zoom;
                    zoom += deltaDistance * 0.005;
                    if (zoom < 0.1) zoom = 0.1;
                    if (zoom > 10) zoom = 10;
                    pos.x = ( (touch1.clientX + touch2.clientX) / 2 ) - rect.left - mouse_x * zoom;
                    pos.y = ( (touch1.clientY + touch2.clientY) / 2 ) - rect.top - mouse_y * zoom;
                        // update()はrequestAnimationFrameで自動呼び出しされるので不要
                }
                this.lastDistance = currentDistance;
            }
        }, { passive: false });
        document.addEventListener('mousemove', function(event) {
//            console.log(event);
            mouse_pos.x = event.clientX;
            mouse_pos.y = event.clientY;
            if (event.buttons === 1) {
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                    // update()はrequestAnimationFrameで自動呼び出しされるので不要
            } else {
                prev_mouse_pos = null;
            }
            // マップ上での座標も計算する
            let mouse_map_pos = { x: 0, y: 0 };
            const map = document.getElementById('map');
            const rect = map.getBoundingClientRect();
            mouse_map_pos.x = (event.clientX - rect.left - pos.x) / zoom;
            mouse_map_pos.y = (event.clientY - rect.top - pos.y) / zoom;
//            console.log(mouse_map_pos);
            const position = document.getElementById('position');
            position.innerText = `(${Math.floor(mouse_map_pos.x)}, ${Math.floor(mouse_map_pos.y)}) Zoom: ${zoom.toFixed(2)}`;
        });
    // 初回起動
    update();
    </script>
</body>
</html>