<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MC Wplace</title>
</head>
<body>
    <div id="position"></div>
    <div id="map"></div>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #888;
        }
        #position {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            padding: 5px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #map {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            user-select: none;
            > .chunk {
                position: absolute;
                width: 128px;
                height: 128px;
                display: grid;
                grid-template-columns: repeat(16, 1fr);
                grid-template-rows: repeat(16, 1fr);
                background: #7FB238;
                transition: background-color 0.5s ease;
                &.loading {
                    animation: pulse 1s infinite;
                }
            }
        }
        @keyframes pulse {
            0% { background-color: #d0d0d0; }
            50% { background-color: #ddd; }
            100% { background-color: #d0d0d0; }
        }
    </style>
    <script>
        let pos = { x: 0, y: 0 };
        let mouse_pos = { x: 0, y: 0 };
        let zoom = 0.5;
        let prev_mouse_pos = null;
        const chunkSize = 16;
        const chunkPixel = 128;
        const loadedChunks = new Map();
        const loadingChunks = new Map(); // key: chunk_key, value: AbortController
        const fetchQueue = [];
        const MAX_CONCURRENT_FETCH = 50;

        const colors = {
            WHITE_WOOL: "#F9FFFE",
            ORANGE_WOOL: "#F9801D",
            MAGENTA_WOOL: "#C74EBD",
            LIGHT_BLUE_WOOL: "#3AB3DA",
            YELLOW_WOOL: "#FED83D",
            LIME_WOOL: "#80C71F",
            PINK_WOOL: "#F38BAA",
            GRAY_WOOL: "#474F52",
            LIGHT_GRAY_WOOL: "#9D9D97",
            CYAN_WOOL: "#169C9C",
            PURPLE_WOOL: "#8932B8",
            BLUE_WOOL: "#3C44AA",
            BROWN_WOOL: "#835432",
            GREEN_WOOL: "#5E7C16",
            RED_WOOL: "#B02E26",
            BLACK_WOOL: "#1D1D21",
            WHITE_CONCRETE_POWDER: "#E7E7E7",
            ORANGE_CONCRETE_POWDER: "#F2B07A",
            MAGENTA_CONCRETE_POWDER: "#B95DAF",
            LIGHT_BLUE_CONCRETE_POWDER: "#8395A7",
            YELLOW_CONCRETE_POWDER: "#E7E23A",
            LIME_CONCRETE_POWDER: "#A7E22E",
            PINK_CONCRETE_POWDER: "#E7A7B7",
            GRAY_CONCRETE_POWDER: "#6D6D6D",
            LIGHT_GRAY_CONCRETE_POWDER: "#BFBFBF",
            CYAN_CONCRETE_POWDER: "#4AABAB",
            PURPLE_CONCRETE_POWDER: "#A24D8E",
            BLUE_CONCRETE_POWDER: "#4A6CD4",
            BROWN_CONCRETE_POWDER: "#A87C5A",
            GREEN_CONCRETE_POWDER: "#7CA15C",
            RED_CONCRETE_POWDER: "#D36C6C",
            BLACK_CONCRETE_POWDER: "#2B2B2B",
            WHITE_CONCRETE: "#F4F4F4",
            ORANGE_CONCRETE: "#FFA400",
            MAGENTA_CONCRETE: "#B24CD8",
            LIGHT_BLUE_CONCRETE: "#6699D8",
            YELLOW_CONCRETE: "#FED83D",
            LIME_CONCRETE: "#80C71F",
            PINK_CONCRETE: "#FFB4B4",
            GRAY_CONCRETE: "#474F52",
            LIGHT_GRAY_CONCRETE: "#9D9D97",
            CYAN_CONCRETE: "#169C9C",
            PURPLE_CONCRETE: "#8932B8",
            BLUE_CONCRETE: "#3C44AA",
            BROWN_CONCRETE: "#835432",
            GREEN_CONCRETE: "#5E7C16",
            RED_CONCRETE: "#B02E26",
            BLACK_CONCRETE: "#1D1D21",
            TERRACOTTA: "#A97A65",
            WHITE_TERRACOTTA: "#D1B1A1",
            ORANGE_TERRACOTTA: "#A35422",
            MAGENTA_TERRACOTTA: "#8E3C7B",
            LIGHT_BLUE_TERRACOTTA: "#6C6EA3",
            YELLOW_TERRACOTTA: "#D0A53C",
            LIME_TERRACOTTA: "#5A7A3C",
            PINK_TERRACOTTA: "#B76A7A",
            GRAY_TERRACOTTA: "#4C4842",
            LIGHT_GRAY_TERRACOTTA: "#9D8B7A",
            CYAN_TERRACOTTA: "#4A686A",
            PURPLE_TERRACOTTA: "#7C3F7C",
            BLUE_TERRACOTTA: "#3C3F7C",
            BROWN_TERRACOTTA: "#4C3222",
            GREEN_TERRACOTTA: "#4C7A3C",
            RED_TERRACOTTA: "#8E3C3C",
            BLACK_TERRACOTTA: "#251610",
            BLACK_GLAZED_TERRACOTTA: "#1D1D21",
            BLUE_GLAZED_TERRACOTTA: "#3C44AA",
            BROWN_GLAZED_TERRACOTTA: "#835432",
            CYAN_GLAZED_TERRACOTTA: "#169C9C",
            GRAY_GLAZED_TERRACOTTA: "#474F52",
            GREEN_GLAZED_TERRACOTTA: "#5E7C16",
            LIGHT_BLUE_GLAZED_TERRACOTTA: "#3AB3DA",
            LIGHT_GRAY_GLAZED_TERRACOTTA: "#9D9D97",
            LIME_GLAZED_TERRACOTTA: "#80C71F",
            MAGENTA_GLAZED_TERRACOTTA: "#C74EBD",
            ORANGE_GLAZED_TERRACOTTA: "#F9801D",
            PINK_GLAZED_TERRACOTTA: "#F38BAA",
            PURPLE_GLAZED_TERRACOTTA: "#8932B8",
            RED_GLAZED_TERRACOTTA: "#B02E26",
            WHITE_GLAZED_TERRACOTTA: "#F9FFFE",
            YELLOW_GLAZED_TERRACOTTA: "#FED83D",
        };

        function getVisibleChunkRange() {
            const map = document.getElementById('map');
            const rect = map.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const centerX = vw / 2 - pos.x;
            const centerY = vh / 2 - pos.y;
            const left = (-pos.x - vw / 2) / zoom;
            const top = (-pos.y - vh / 2) / zoom;
            const right = (vw / 2 - pos.x) / zoom;
            const bottom = (vh / 2 - pos.y) / zoom;
            const chunkLeft = Math.floor(left / chunkPixel);
            const chunkRight = Math.floor(right / chunkPixel);
            const chunkTop = Math.floor(top / chunkPixel);
            const chunkBottom = Math.floor(bottom / chunkPixel);
            return {
                left: chunkLeft,
                right: chunkRight,
                top: chunkTop,
                bottom: chunkBottom
            };
        }

        async function loadChunk(x, y) {
            const key = `${x}_${y}`;
            if (loadedChunks.has(key) || loadingChunks.has(key)) return;
            const map = document.getElementById('map');
            const chunkEl = document.createElement('div');
            chunkEl.className = 'chunk loading';
            chunkEl.style.left = `${x * chunkPixel}px`;
            chunkEl.style.top = `${y * chunkPixel}px`;
            chunkEl.dataset.chunk = key;
            map.appendChild(chunkEl);
            loadedChunks.set(key, { element: chunkEl, data: null });
            // キューに追加
            fetchQueue.push({ key, chunkEl, x, y, retryCount: 0 });
            processFetchQueue();
        }

        async function processFetchQueue() {
            if (loadingChunks.size >= MAX_CONCURRENT_FETCH) return;
            if (fetchQueue.length === 0) return;
            const { key, chunkEl, x, y, retryCount } = fetchQueue.shift();
            
            // AbortController作成
            const abortController = new AbortController();
            loadingChunks.set(key, abortController);
            
            try {
                const res = await fetch(`/mapfiles/${key}.json`, {
                    signal: abortController.signal
                });
                chunkEl.classList.remove('loading');
                let data = null;
                try {
                    data = await res.json();
                } catch (e) {}
                if (data === null) {
                    data = new Array(chunkSize * chunkSize).fill(0);
                }
                const chunkData = loadedChunks.get(key);
                if (chunkData) {
                    chunkData.data = data;
                    for (let by = 0; by < chunkSize; by++) {
                        for (let bx = 0; bx < chunkSize; bx++) {
                            const idx = by * chunkSize + bx;
                            const blockType = data[idx];
                            if (!blockType || blockType === 0) continue;
                            const block = document.createElement('div');
                            block.className = 'block';
                            block.style.gridColumn = bx + 1;
                            block.style.gridRow = by + 1;
                            block.style.background = colors[blockType] || '#7FB238';
                            chunkEl.appendChild(block);
                        }
                    }
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    // abort時は再試行しない
                    if (loadedChunks.has(key)) {
                        chunkEl.remove();
                        loadedChunks.delete(key);
                    }
                } else {
                    // 失敗時は再試行（最大3回）
                    if (retryCount < 3) {
                        fetchQueue.unshift({ key, chunkEl, x, y, retryCount: retryCount + 1 });
                    } else {
                        // 最大試行回数に達したら削除
                        chunkEl.remove();
                        loadedChunks.delete(key);
                    }
                }
            } finally {
                loadingChunks.delete(key);
                // 次のfetchを進める
                processFetchQueue();
            }
        }

        function cleanupChunks(visible) {
            for (const [key, value] of loadedChunks.entries()) {
                const [x, y] = key.split('_').map(Number);
                if (x < visible.left || x > visible.right || y < visible.top || y > visible.bottom) {
                    // 読み込み中のfetchをabort
                    if (loadingChunks.has(key)) {
                        loadingChunks.get(key).abort();
                        loadingChunks.delete(key);
                    }
                    // キューからも削除
                    const queueIndex = fetchQueue.findIndex(item => item.key === key);
                    if (queueIndex !== -1) {
                        fetchQueue.splice(queueIndex, 1);
                    }
                    value.element.remove();
                    loadedChunks.delete(key);
                }
            }
        }

        async function update() {
            const map = document.getElementById('map');
            map.style.transform = `translate(calc(-50% + ${pos.x}px), calc(-50% + ${pos.y}px)) scale(${zoom})`;
            // 表示範囲のチャンク計算
            const visible = getVisibleChunkRange();
            // 必要なチャンクだけ描画・fetch
            for (let cx = visible.left; cx <= visible.right; cx++) {
                for (let cy = visible.top; cy <= visible.bottom; cy++) {
                    loadChunk(cx, cy);
                }
            }
            // 範囲外チャンク削除
            cleanupChunks(visible);
            requestAnimationFrame(update);
        }
        document.addEventListener('wheel', function(event) {
            event.preventDefault();
            const prev_zoom = zoom;
            // ズーム中心（画面中心からの相対座標）
            const centerScreenX = event.clientX - window.innerWidth / 2;
            const centerScreenY = event.clientY - window.innerHeight / 2;
            // ズーム前のmap座標
            const mapX = (centerScreenX - pos.x) / prev_zoom;
            const mapY = (centerScreenY - pos.y) / prev_zoom;
            if (event.deltaY < 0) {
                zoom += event.deltaY * -0.005;
            } else {
                zoom -= event.deltaY * 0.005;
            }
            if (zoom < 0.25) zoom = 0.25;
            if (zoom > 10) zoom = 10;
            // ズーム後も同じmap座標が同じ画面座標になるようにpos調整
            pos.x = centerScreenX - mapX * zoom;
            pos.y = centerScreenY - mapY * zoom;
        }, { passive: false });
        // 二本指ズームに対応
        // タッチ用の前回位置保存
        let lastTouchCenter = null;
        // ジェスチャー用の状態管理
        let gestureStartScale = 1;
        let gestureStartPos = { x: 0, y: 0 };
        let gestureCenter = { x: 0, y: 0 };

        document.addEventListener('gesturestart', function(event) {
            event.preventDefault();
            gestureStartScale = zoom;
            gestureStartPos = { x: pos.x, y: pos.y };
            gestureCenter = {
                x: event.clientX - window.innerWidth / 2,
                y: event.clientY - window.innerHeight / 2
            };
        }, { passive: false });

        document.addEventListener('gesturechange', function(event) {
            event.preventDefault();
            const newZoom = gestureStartScale * event.scale;
            if (newZoom < 0.25 || newZoom > 10) return;
            
            // ジェスチャー開始時のmap座標
            const mapX = (gestureCenter.x - gestureStartPos.x) / gestureStartScale;
            const mapY = (gestureCenter.y - gestureStartPos.y) / gestureStartScale;
            
            // 新しいズームとポジション
            zoom = newZoom;
            pos.x = gestureCenter.x - mapX * zoom;
            pos.y = gestureCenter.y - mapY * zoom;
        }, { passive: false });

        document.addEventListener('gestureend', function(event) {
            event.preventDefault();
            // 最終的な調整
            const newZoom = gestureStartScale * event.scale;
            if (newZoom >= 0.25 && newZoom <= 10) {
                const mapX = (gestureCenter.x - gestureStartPos.x) / gestureStartScale;
                const mapY = (gestureCenter.y - gestureStartPos.y) / gestureStartScale;
                zoom = newZoom;
                pos.x = gestureCenter.x - mapX * zoom;
                pos.y = gestureCenter.y - mapY * zoom;
            }
        }, { passive: false });

        document.addEventListener('touchmove', function(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const currentCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // 移動処理（2本指の中点の移動）
                if (lastTouchCenter) {
                    pos.x += (currentCenter.x - lastTouchCenter.x);
                    pos.y += (currentCenter.y - lastTouchCenter.y);
                }
                
                // ズーム処理
                if (this.lastDistance) {
                    const prev_zoom = zoom;
                    // ズーム中心（画面中心からの相対座標）
                    const centerScreenX = currentCenter.x - window.innerWidth / 2;
                    const centerScreenY = currentCenter.y - window.innerHeight / 2;
                    // ズーム前のmap座標
                    const mapX = (centerScreenX - pos.x) / prev_zoom;
                    const mapY = (centerScreenY - pos.y) / prev_zoom;
                    const deltaDistance = currentDistance - this.lastDistance;
                    zoom += deltaDistance * 0.005;
                    if (zoom < 0.25) zoom = 0.25;
                    if (zoom > 10) zoom = 10;
                    // ズーム後も同じmap座標が同じ画面座標になるようにpos調整
                    pos.x = centerScreenX - mapX * zoom;
                    pos.y = centerScreenY - mapY * zoom;
                }
                
                this.lastDistance = currentDistance;
                lastTouchCenter = currentCenter;
                return;
            }
            // 移動も対応
            if (event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0];
                mouse_pos.x = touch.clientX;
                mouse_pos.y = touch.clientY;
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                    // update()はrequestAnimationFrameで自動呼び出しされるので不要
            }
        }, { passive: false });
            document.addEventListener('touchend', function(event) {
                prev_mouse_pos = null;
                lastTouchCenter = null;
                // 2本指ズーム終了時もlastDistanceリセット
                this.lastDistance = null;
            });
        document.addEventListener('mousemove', function(event) {
//            console.log(event);
            mouse_pos.x = event.clientX;
            mouse_pos.y = event.clientY;
            if (event.buttons === 1) {
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                    // update()はrequestAnimationFrameで自動呼び出しされるので不要
            } else {
                prev_mouse_pos = null;
            }
            // マップ上での座標も計算する
            let mouse_map_pos = { x: 0, y: 0 };
            const map = document.getElementById('map');
            const rect = map.getBoundingClientRect();
            mouse_map_pos.x = (event.clientX - rect.left - pos.x) / zoom;
            mouse_map_pos.y = (event.clientY - rect.top - pos.y) / zoom;
//            console.log(mouse_map_pos);
            const position = document.getElementById('position');
            position.innerText = `(${Math.floor(mouse_map_pos.x)}, ${Math.floor(mouse_map_pos.y)}) Zoom: ${zoom.toFixed(2)}`;
        });
    // 初回起動
    update();
    </script>
</body>
</html>