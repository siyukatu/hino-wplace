<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mplace</title>
</head>
<body>
    <div id="position"></div>
    <div id="center-pointer"></div>
    <div id="center-tooltip"></div>
    <div id="map"></div>
    <h1 id="info">
        Mplace by <a href="https://www.youtube.com/@hino_YT" target="_blank">ヒノ</a> | Sponsored by <a href="https://vps.xserver.ne.jp/game-server/" target="_blank">Xserver</a><br>
    </h1>
    <div id="ranking">
        <div class="modal">
            <h2>ランキング</h2>
            <small>
                ブロック設置数
            </small>
            <div id="ranking-list"></div>
        </div>
    </div>
    <button id="ranking-button">
        <svg xmlns="http://www.w3.org/2000/svg" height="1.2em" viewBox="0 -960 960 960" width="1.2em" fill="currentColor"><path d="M280-120v-80h160v-124q-49-11-87.5-41.5T296-442q-75-9-125.5-65.5T120-640v-40q0-33 23.5-56.5T200-760h80v-80h400v80h80q33 0 56.5 23.5T840-680v40q0 76-50.5 132.5T664-442q-18 46-56.5 76.5T520-324v124h160v80H280Zm0-408v-152h-80v40q0 38 22 68.5t58 43.5Zm400 0q36-13 58-43.5t22-68.5v-40h-80v152Z"/></svg>
        ランキング
    </button>
    <div id="zoom-controls">
        <button id="zoom-in"></button>
        <button id="zoom-out"></button>
    </div>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #888;
            color: #333;
            font-family: sans-serif;
            position: fixed;
            top: 0;
            left: 0;
        }
        #position {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 5px 10px;
            /* border: 1px solid #aaa; */
            border-radius: 2.5px;
            font-size: 0.8em;
            color: #fff;
            z-index: 1000;
        }
        #info {
            all: unset;
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 0 5px;
            z-index: 1000;
            font-size: 0.8em;
            color: #fff;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            opacity: 0.7;
            transition: opacity 0.3s ease;
            &:hover {
                opacity: 1.0;
            }
            > a {
                color: currentColor;
                text-decoration: underline;
            }
        }
        #ranking {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: flex;
            &:not(.show) {
                display: none;
            }
            > .modal {
                color: #fff;
                background: #222c;
                max-width: 300px;
                width: 100%;
                backdrop-filter: blur(10px);
                box-shadow: 0 0 10px #0002;
                box-sizing: border-box;
                margin: auto;
                padding: 10px 12.5px;
                > h2 {
                    all: unset;
                    font-size: 1.1em;
                    display: block;
                }
                > small {
                    font-size: 0.8em;
                    display: flex;
                    gap: 0.5px;
                }
                > #ranking-list {
                    > .rank {
                        position: relative;
                        margin-top: 10px;
                        display: flex;
                        padding: 7.5px;
                        background: #0007;
                        border-radius: 3px;
                        &:nth-child(1) {
                            > .crown {
                                fill: gold;
                            }
                        }
                        &:nth-child(2) {
                            > .crown {
                                fill: silver;
                            }
                        }
                        &:nth-child(3) {
                            > .crown {
                                fill: #cd7f32;
                            }
                        }
                        > .crown {
                            position: absolute;
                            top: -10px;
                            right: 0px;
                            width: 1.5em;
                            height: 1.5em;
                            transform: rotate(15deg);
                        }
                        > .headimg {
                            height: 2.5em;
                            aspect-ratio: 1;
                            image-rendering: pixelated;
                            border: solid 1px #555;
                        }
                        > .details {
                            margin-left: 7.5px;
                            margin-block: 2px;
                            flex-grow: 1;
                            display: flex;
                            flex-direction: column;
                            > h3 {
                                all: unset;
                                display: block;
                                font-size: 0.9em;
                                line-height: 1;
                            }
                            > .graph {
                                display: flex;
                                border-bottom: solid 1px #888;
                                margin-top: 5px;
                                flex-grow: 1;
                                gap: 4px;
                                padding: 0 5px;
                                > .stick {
                                    background: #ddd;
                                    width: 100%;
                                    margin-top: auto;
                                }
                            }
                        }
                    }
                }
            }
        }
        #ranking-button {
            all: unset;
            position: fixed;
            top: 10px;
            right: 10px;
            cursor: pointer;
            display: flex;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transition: background 0.1s ease;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            line-height: 1;
            font-size: 0.9em;
            padding: 0.65em 0.85em;
            align-items: center;
            gap: 0.15em;
            border-radius: 3.5px;
        }
        #zoom-controls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            z-index: 1001;
            background: rgba(0,0,0,0.75);
            overflow: hidden;
            border-radius: 3.5px;
            > button {
                all: unset;
                position: relative;
                width: 2.5em;
                height: 2.5em;
                cursor: pointer;
                display: flex;
                box-shadow: 0 0 5px rgba(0,0,0,0.3);
                transition: background 0.1s ease;
                &:hover {
                    background: rgba(255,255,255,0.2);
                }
            }
            #zoom-in {
                &::before, &::after {
                    content: '';
                    position: absolute;
                    background: #fff;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 1em;
                    height: 0.175em;
                }
                &::after {
                    width: 0.175em;
                    height: 1em;
                }
            }
            #zoom-out {
                &::before {
                    content: '';
                    position: absolute;
                    background: #fff;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 1em;
                    height: 0.175em;
                }
            }
        }
        #center-pointer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1002;
            display: none;
        }
        #center-pointer::before,
        #center-pointer::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.3);
        }
        #center-pointer::before {
            top: 50%;
            left: 8px;
            right: 8px;
            height: 2px;
            transform: translateY(-50%);
        }
        #center-pointer::after {
            left: 50%;
            top: 8px;
            bottom: 8px;
            width: 2px;
            transform: translateX(-50%);
        }
        #center-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -120%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1003;
            display: none;
        }
        #map {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            user-select: none;
            width: 0;
            height: 0;
            overflow: visible;
        }
        .player {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 1001;
            pointer-events: none;
            display: flex;
            align-items: center;
            > .icon {
                width: 2em;
                height: 2em;
                image-rendering: pixelated;
                border: solid 1px #555;
                display: flex;
            }
            > .info {
                position: absolute;
                background: rgba(0, 0, 0, 0.75);
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                padding: 1px 5px;
                margin-top: 5px;
                border-radius: 3px;
                font-size: 0.85em;
                color: #fff;
                white-space: nowrap;
                text-shadow: 0 0 2px #000a;
                text-align: center;
                > .name {
                    display: block;
                }
                > .position {
                    font-size: 0.7em;
                    opacity: 0.75;
                }
            }
        }
    </style>
    <script>
        // 設定定数
        const MIN_ZOOM = 0.25;
        const MAX_ZOOM = 3.5;
        
        let pos = { x: 0, y: 0 };
        let mouse_pos = { x: 0, y: 0 };
        let zoom = 0.5;
        let prev_mouse_pos = null;
        const chunkSize = 16;
        const chunkPixel = 128;
        const loadedChunks = new Map();
        const loadingChunks = new Map(); // key: chunk_key, value: AbortController
        const fetchQueue = [];
        const MAX_CONCURRENT_FETCH = 50;

        // プレイヤー管理
        const playerElements = new Map(); // uuid -> DOM element
        let playerData = new Map(); // uuid -> {name, x, z}

        const map = document.getElementById('map');

        // URLハッシュ管理
        function updateURLHash() {
            // 画面中央の座標をマインクラフト座標に変換
            const centerX = -pos.x / zoom;
            const centerY = -pos.y / zoom;
            const mc_x = Math.floor(centerX * 16 / chunkPixel);
            const mc_y = Math.floor(centerY * 16 / chunkPixel);
            
            const hash = `#pos=${mc_x},${mc_y}&zoom=${zoom.toFixed(2)}`;
            if (window.location.hash !== hash) {
                window.history.replaceState(null, null, hash);
            }
        }

        function loadFromURLHash() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                const params = new URLSearchParams(hash);
                const posParam = params.get('pos');
                const zoomParam = params.get('zoom');
                
                // 先にzoomを設定
                if (zoomParam) {
                    const zoomValue = parseFloat(zoomParam);
                    if (!isNaN(zoomValue) && zoomValue >= MIN_ZOOM && zoomValue <= MAX_ZOOM) {
                        zoom = zoomValue;
                    }
                }
                
                // zoomが設定された後にposを計算
                if (posParam) {
                    const [mc_x, mc_y] = posParam.split(',').map(Number);
                    if (!isNaN(mc_x) && !isNaN(mc_y)) {
                        // マインクラフト座標をマップピクセル座標に変換
                        // mc座標 -> マップピクセル座標: mc * chunkPixel / 16
                        const mapX = (mc_x * chunkPixel) / 16;
                        const mapY = (mc_y * chunkPixel) / 16;
                        // マップピクセル座標をpos座標に変換（画面中央に配置）
                        // pos = -mapPixel * zoom（画面中央が原点になるように）
                        pos.x = -mapX * zoom;
                        pos.y = -mapY * zoom;
                    }
                }
            }
        }

        // 座標表示の更新（変化があった場合のみ）
        let lastDisplayedPosition = null;
        function updatePositionDisplay() {
            const map_pos = { x: 0, y: 0 };
            // チャンク座標系に変換（Minecraft座標）
            map_pos.x = (mouse_pos.x - window.innerWidth / 2 - pos.x) / zoom;
            map_pos.y = (mouse_pos.y - window.innerHeight / 2 - pos.y) / zoom;
            // ピクセル座標をMinecraft座標に変換
            const mc_x = Math.floor(map_pos.x * 16 / chunkPixel);
            const mc_y = Math.floor(map_pos.y * 16 / chunkPixel);
            const zoomRounded = Math.round(zoom * 100) / 100; // 小数点以下2桁で丸める
            
            const currentPosition = `${mc_x}, ${mc_y}`;
            
            // 前回と同じ内容の場合は更新しない
            if (lastDisplayedPosition !== currentPosition) {
                const position = document.getElementById('position');
                position.innerText = currentPosition;
                lastDisplayedPosition = currentPosition;
            }
        }

        // 画面中央のツールチップ表示
        function showCenterTooltip() {
            const centerPointer = document.getElementById('center-pointer');
            const centerTooltip = document.getElementById('center-tooltip');
            centerPointer.style.display = 'block';
            centerTooltip.style.display = 'block';
            
            // 画面中央の座標を計算
            const centerX = -pos.x / zoom;
            const centerY = -pos.y / zoom;
            const mc_x = Math.floor(centerX * 16 / chunkPixel);
            const mc_y = Math.floor(centerY * 16 / chunkPixel);
            centerTooltip.innerText = `${mc_x}, ${mc_y}`;
        }

        function hideCenterTooltip() {
            const centerPointer = document.getElementById('center-pointer');
            const centerTooltip = document.getElementById('center-tooltip');
            centerPointer.style.display = 'none';
            centerTooltip.style.display = 'none';
        }

        // プレイヤーデータの取得
        async function fetchPlayerData() {
            try {
                const response = await fetch('/data/players.txt');
                const text = await response.text();
                const newPlayerData = new Map();
                
                if (text.trim()) {
                    const lines = text.trim().split('\n');
                    for (const line of lines) {
                        const [uuid, name, x, z] = line.split(',');
                        if (uuid && name && x && z) {
                            newPlayerData.set(uuid, {
                                name: name,
                                x: parseInt(x),
                                z: parseInt(z)
                            });
                        }
                    }
                }
                
                playerData = newPlayerData;
                updatePlayerDisplay();
            } catch (error) {
                console.warn('Failed to fetch player data:', error);
            }
        }

        // プレイヤー表示の更新
        function updatePlayerDisplay() {
            const visible = getVisibleChunkRange();
            const visibleMinX = visible.left * chunkSize;
            const visibleMaxX = (visible.right + 1) * chunkSize;
            const visibleMinZ = visible.top * chunkSize;
            const visibleMaxZ = (visible.bottom + 1) * chunkSize;

            // 既存のプレイヤー要素をチェック
            for (const [uuid, element] of playerElements) {
                if (!playerData.has(uuid)) {
                    // プレイヤーが存在しない場合は削除
                    element.remove();
                    playerElements.delete(uuid);
                }
            }

            // プレイヤーデータをチェックして表示/非表示を更新
            for (const [uuid, player] of playerData) {
                const isVisible = player.x >= visibleMinX && player.x <= visibleMaxX &&
                                player.z >= visibleMinZ && player.z <= visibleMaxZ;

                if (isVisible) {
                    // 表示範囲内にいる場合
                    let playerElement = playerElements.get(uuid);
                    
                    if (!playerElement) {
                        // 新しいプレイヤー要素を作成
                        playerElement = document.createElement('div');
                        playerElement.className = 'player';
                        const icon = document.createElement('img');
                        icon.className = 'icon';
                        icon.src = `http://mcskinapi.siyukatu.com/heads/${uuid}`;
                        playerElement.appendChild(icon);
                        const info = document.createElement('div');
                        info.className = 'info';
                        const name = document.createElement('div');
                        name.className = 'name';
                        name.innerText = player.name;
                        info.appendChild(name);
                        const position = document.createElement('div');
                        position.className = 'position';
                        position.innerText = `${player.x}, ${player.z}`;
                        info.appendChild(position);
                        playerElement.appendChild(info);
                        document.body.appendChild(playerElement);
                        playerElements.set(uuid, playerElement);
                    }

                    // 位置を更新
                    const mapX = (player.x * chunkPixel) / 16;
                    const mapZ = (player.z * chunkPixel) / 16;
                    // マップ座標を画面座標に変換（ズームと位置を考慮）
                    const screenX = window.innerWidth / 2 + pos.x + mapX * zoom;
                    const screenZ = window.innerHeight / 2 + pos.y + mapZ * zoom;
                    playerElement.style.left = `${screenX}px`;
                    playerElement.style.top = `${screenZ}px`;
                    playerElement.style.display = 'flex';
                } else {
                    // 表示範囲外にいる場合
                    const playerElement = playerElements.get(uuid);
                    if (playerElement) {
                        playerElement.style.display = 'none';
                    }
                }
            }
        }

        const colors = {
            WHITE_WOOL: "#F9FFFE",
            ORANGE_WOOL: "#F9801D",
            MAGENTA_WOOL: "#C74EBD",
            LIGHT_BLUE_WOOL: "#3AB3DA",
            YELLOW_WOOL: "#FED83D",
            LIME_WOOL: "#80C71F",
            PINK_WOOL: "#F38BAA",
            GRAY_WOOL: "#474F52",
            LIGHT_GRAY_WOOL: "#9D9D97",
            CYAN_WOOL: "#169C9C",
            PURPLE_WOOL: "#8932B8",
            BLUE_WOOL: "#3C44AA",
            BROWN_WOOL: "#835432",
            GREEN_WOOL: "#5E7C16",
            RED_WOOL: "#B02E26",
            BLACK_WOOL: "#1D1D21",
            WHITE_CONCRETE_POWDER: "#E7E7E7",
            ORANGE_CONCRETE_POWDER: "#F2B07A",
            MAGENTA_CONCRETE_POWDER: "#B95DAF",
            LIGHT_BLUE_CONCRETE_POWDER: "#8395A7",
            YELLOW_CONCRETE_POWDER: "#E7E23A",
            LIME_CONCRETE_POWDER: "#A7E22E",
            PINK_CONCRETE_POWDER: "#E7A7B7",
            GRAY_CONCRETE_POWDER: "#6D6D6D",
            LIGHT_GRAY_CONCRETE_POWDER: "#BFBFBF",
            CYAN_CONCRETE_POWDER: "#4AABAB",
            PURPLE_CONCRETE_POWDER: "#A24D8E",
            BLUE_CONCRETE_POWDER: "#4A6CD4",
            BROWN_CONCRETE_POWDER: "#A87C5A",
            GREEN_CONCRETE_POWDER: "#7CA15C",
            RED_CONCRETE_POWDER: "#D36C6C",
            BLACK_CONCRETE_POWDER: "#2B2B2B",
            WHITE_CONCRETE: "#F4F4F4",
            ORANGE_CONCRETE: "#FFA400",
            MAGENTA_CONCRETE: "#B24CD8",
            LIGHT_BLUE_CONCRETE: "#6699D8",
            YELLOW_CONCRETE: "#FED83D",
            LIME_CONCRETE: "#80C71F",
            PINK_CONCRETE: "#FFB4B4",
            GRAY_CONCRETE: "#474F52",
            LIGHT_GRAY_CONCRETE: "#9D9D97",
            CYAN_CONCRETE: "#169C9C",
            PURPLE_CONCRETE: "#8932B8",
            BLUE_CONCRETE: "#3C44AA",
            BROWN_CONCRETE: "#835432",
            GREEN_CONCRETE: "#5E7C16",
            RED_CONCRETE: "#B02E26",
            BLACK_CONCRETE: "#1D1D21",
            TERRACOTTA: "#A97A65",
            WHITE_TERRACOTTA: "#D1B1A1",
            ORANGE_TERRACOTTA: "#A35422",
            MAGENTA_TERRACOTTA: "#8E3C7B",
            LIGHT_BLUE_TERRACOTTA: "#6C6EA3",
            YELLOW_TERRACOTTA: "#D0A53C",
            LIME_TERRACOTTA: "#5A7A3C",
            PINK_TERRACOTTA: "#B76A7A",
            GRAY_TERRACOTTA: "#4C4842",
            LIGHT_GRAY_TERRACOTTA: "#9D8B7A",
            CYAN_TERRACOTTA: "#4A686A",
            PURPLE_TERRACOTTA: "#7C3F7C",
            BLUE_TERRACOTTA: "#3C3F7C",
            BROWN_TERRACOTTA: "#4C3222",
            GREEN_TERRACOTTA: "#4C7A3C",
            RED_TERRACOTTA: "#8E3C3C",
            BLACK_TERRACOTTA: "#251610",
            BLACK_GLAZED_TERRACOTTA: "#1D1D21",
            BLUE_GLAZED_TERRACOTTA: "#3C44AA",
            BROWN_GLAZED_TERRACOTTA: "#835432",
            CYAN_GLAZED_TERRACOTTA: "#169C9C",
            GRAY_GLAZED_TERRACOTTA: "#474F52",
            GREEN_GLAZED_TERRACOTTA: "#5E7C16",
            LIGHT_BLUE_GLAZED_TERRACOTTA: "#3AB3DA",
            LIGHT_GRAY_GLAZED_TERRACOTTA: "#9D9D97",
            LIME_GLAZED_TERRACOTTA: "#80C71F",
            MAGENTA_GLAZED_TERRACOTTA: "#C74EBD",
            ORANGE_GLAZED_TERRACOTTA: "#F9801D",
            PINK_GLAZED_TERRACOTTA: "#F38BAA",
            PURPLE_GLAZED_TERRACOTTA: "#8932B8",
            RED_GLAZED_TERRACOTTA: "#B02E26",
            WHITE_GLAZED_TERRACOTTA: "#F9FFFE",
            YELLOW_GLAZED_TERRACOTTA: "#FED83D",
            WATER: "#3F76E4",
            GRASS_BLOCK: "#7FB238",
            DIRT: "#8B4513",
            STONE: "#888888",
            SAND: "#FAF0C4",
        };

        function getVisibleChunkRange() {
            const rect = map.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const centerX = vw / 2 - pos.x;
            const centerY = vh / 2 - pos.y;
            const left = (-pos.x - vw / 2) / zoom;
            const top = (-pos.y - vh / 2) / zoom;
            const right = (vw / 2 - pos.x) / zoom;
            const bottom = (vh / 2 - pos.y) / zoom;
            const chunkLeft = Math.floor(left / chunkPixel);
            const chunkRight = Math.floor(right / chunkPixel);
            const chunkTop = Math.floor(top / chunkPixel);
            const chunkBottom = Math.floor(bottom / chunkPixel);
            return {
                left: chunkLeft,
                right: chunkRight,
                top: chunkTop,
                bottom: chunkBottom
            };
        }

        async function loadChunk(x, y, priority = 0) {
            const key = `${x}_${y}`;
            if (loadedChunks.has(key) || loadingChunks.has(key)) return;
            
            // Canvas要素を作成
            const canvas = document.createElement('canvas');
            canvas.width = chunkPixel;
            canvas.height = chunkPixel;
            canvas.style.position = 'absolute';
            canvas.style.left = `${x * chunkPixel}px`;
            canvas.style.top = `${y * chunkPixel}px`;
            canvas.style.imageRendering = 'pixelated'; // ピクセルアートを鮮明に表示
            canvas.dataset.chunk = key;
            map.appendChild(canvas);
            
            loadedChunks.set(key, { element: canvas, data: null, canvas: canvas });
            // 優先度付きでキューに追加
            const chunkData = { key, canvas, x, y, retryCount: 0, priority };
            
            // 優先度に基づいて挿入位置を決定
            let insertIndex = fetchQueue.length;
            for (let i = 0; i < fetchQueue.length; i++) {
                if (fetchQueue[i].priority > priority) {
                    insertIndex = i;
                    break;
                }
            }
            fetchQueue.splice(insertIndex, 0, chunkData);
            processFetchQueue();
        }

        async function processFetchQueue() {
            if (loadingChunks.size >= MAX_CONCURRENT_FETCH) return;
            if (fetchQueue.length === 0) return;
            const { key, canvas, x, y, retryCount, priority } = fetchQueue.shift();
            
            // AbortController作成
            const abortController = new AbortController();
            loadingChunks.set(key, abortController);
            
            try {
                const res = await fetch(`/data/mapfiles/${key}.json`, {
                    signal: abortController.signal
                });
                let data = null;
                try {
                    data = await res.json();
                } catch (e) {}
                if (data === null) {
                    data = new Array(chunkSize * chunkSize).fill(0);
                }
                
                const chunkData = loadedChunks.get(key);
                if (chunkData && canvas) {
                    chunkData.data = data;
                    
                    // Canvasに描画
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false; // ピクセルアートを鮮明に
                    
                    const blockSize = chunkPixel / chunkSize; // 1ブロックのピクセル数
                    
                    for (let by = 0; by < chunkSize; by++) {
                        for (let bx = 0; bx < chunkSize; bx++) {
                            const idx = by * chunkSize + bx;
                            const blockType = data[idx];
                            const color = colors[blockType] || '#aaa';
                            
                            ctx.fillStyle = color;
                            ctx.fillRect(bx * blockSize, by * blockSize, blockSize, blockSize);
                        }
                    }
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    // abort時は再試行しない
                    if (loadedChunks.has(key)) {
                        canvas.remove();
                        loadedChunks.delete(key);
                    }
                } else {
                    // 失敗時は再試行（最大3回）優先度を保持
                    if (retryCount < 3) {
                        fetchQueue.unshift({ key, canvas, x, y, retryCount: retryCount + 1, priority });
                    } else {
                        // 最大試行回数に達したら削除
                        canvas.remove();
                        loadedChunks.delete(key);
                    }
                }
            } finally {
                loadingChunks.delete(key);
                // 次のfetchを進める
                processFetchQueue();
            }
        }

        function cleanupChunks(visible) {
            for (const [key, value] of loadedChunks.entries()) {
                const [x, y] = key.split('_').map(Number);
                if (x < visible.left || x > visible.right || y < visible.top || y > visible.bottom) {
                    // 読み込み中のfetchをabort
                    if (loadingChunks.has(key)) {
                        loadingChunks.get(key).abort();
                        loadingChunks.delete(key);
                    }
                    // キューからも削除
                    const queueIndex = fetchQueue.findIndex(item => item.key === key);
                    if (queueIndex !== -1) {
                        fetchQueue.splice(queueIndex, 1);
                    }
                    value.element.remove();
                    loadedChunks.delete(key);
                }
            }
        }

        async function update() {
            map.style.transform = `translate(calc(-50% + ${pos.x}px), calc(-50% + ${pos.y}px)) scale(${zoom})`;
            // 表示範囲のチャンク計算
            const visible = getVisibleChunkRange();
            
            // 画面中央のチャンク座標計算
            const centerChunkX = Math.floor((-pos.x) / zoom / chunkPixel);
            const centerChunkY = Math.floor((-pos.y) / zoom / chunkPixel);
            
            // 必要なチャンクを中央からの距離順でソート
            const chunksToLoad = [];
            for (let cx = visible.left; cx <= visible.right; cx++) {
                for (let cy = visible.top; cy <= visible.bottom; cy++) {
                    const distance = Math.sqrt(Math.pow(cx - centerChunkX, 2) + Math.pow(cy - centerChunkY, 2));
                    chunksToLoad.push({ x: cx, y: cy, distance: distance });
                }
            }
            
            // 距離順でソート（近いものから優先）
            chunksToLoad.sort((a, b) => a.distance - b.distance);
            
            // ソートされた順序でチャンクをロード（優先度付き）
            for (let i = 0; i < chunksToLoad.length; i++) {
                const chunk = chunksToLoad[i];
                loadChunk(chunk.x, chunk.y, chunk.distance);
            }
            
            // 範囲外チャンク削除
            cleanupChunks(visible);
            
            // プレイヤー表示更新
            updatePlayerDisplay();
            
            requestAnimationFrame(update);
        }
        map.addEventListener('wheel', function(event) {
            event.preventDefault();
            
            // wheel操作中はcentertooltipを表示
            showCenterTooltip();
            
            // マウスとタッチパッドの判定
            // マウスホイール: 通常は120の倍数の離散値
            // タッチパッド: 連続的な小さな値
            const isTrackpad = Math.abs(event.deltaY) < 50 || event.deltaY % 1 !== 0;
            
            // トラックパッドのピンチ操作の検出（Ctrl+wheel）
            if (event.ctrlKey) {
                // ピンチズーム操作
                const prev_zoom = zoom;
                const centerScreenX = event.clientX - window.innerWidth / 2;
                const centerScreenY = event.clientY - window.innerHeight / 2;
                const mapX = (centerScreenX - pos.x) / prev_zoom;
                const mapY = (centerScreenY - pos.y) / prev_zoom;
                
                if (event.deltaY < 0) {
                    zoom += event.deltaY * -0.01;
                } else {
                    zoom -= event.deltaY * 0.01;
                }
                if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
                if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
                
                pos.x = centerScreenX - mapX * zoom;
                pos.y = centerScreenY - mapY * zoom;
                updateURLHash();
            } else if (isTrackpad) {
                // タッチパッド: 移動操作
                pos.x -= event.deltaX * 1;
                pos.y -= event.deltaY * 1;
                updateURLHash();
            } else {
                // マウスホイール: ズーム操作
                const prev_zoom = zoom;
                const centerScreenX = event.clientX - window.innerWidth / 2;
                const centerScreenY = event.clientY - window.innerHeight / 2;
                const mapX = (centerScreenX - pos.x) / prev_zoom;
                const mapY = (centerScreenY - pos.y) / prev_zoom;
                
                if (event.deltaY < 0) {
                    zoom += 0.1; // ズームイン
                } else {
                    zoom -= 0.1; // ズームアウト
                }
                if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
                if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
                
                pos.x = centerScreenX - mapX * zoom;
                pos.y = centerScreenY - mapY * zoom;
                updateURLHash();
            }
            
            // wheel操作終了の検知のためのタイマー設定
            clearTimeout(this.wheelTimer);
            this.wheelTimer = setTimeout(() => {
                hideCenterTooltip();
            }, 200);
        }, { passive: false });
        // 二本指ズームに対応
        // タッチ用の前回位置保存
        let lastTouchCenter = null;
        let lastTouchDistance = null;

        map.addEventListener('touchstart', function(event) {
            if (event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                lastTouchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                lastTouchCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
        });

        map.addEventListener('touchmove', function(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const currentCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // 移動処理（2本指の中点の移動）
                if (lastTouchCenter) {
                    const deltaX = currentCenter.x - lastTouchCenter.x;
                    const deltaY = currentCenter.y - lastTouchCenter.y;
                    pos.x += deltaX;
                    pos.y += deltaY;
                }
                
                // ズーム処理（距離変化が閾値を超える場合のみ）
                if (lastTouchDistance && Math.abs(currentDistance - lastTouchDistance) > 2) {
                    const prev_zoom = zoom;
                    // ズーム中心（画面中心からの相対座標）
                    const centerScreenX = currentCenter.x - window.innerWidth / 2;
                    const centerScreenY = currentCenter.y - window.innerHeight / 2;
                    // ズーム前のmap座標（移動後のposを使用）
                    const mapX = (centerScreenX - pos.x) / prev_zoom;
                    const mapY = (centerScreenY - pos.y) / prev_zoom;
                    const deltaDistance = currentDistance - lastTouchDistance;
                    zoom += deltaDistance * 0.008;
                    if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
                    if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
                    // ズーム後も同じmap座標が同じ画面座標になるようにpos調整
                    pos.x = centerScreenX - mapX * zoom;
                    pos.y = centerScreenY - mapY * zoom;
                    
                    // ズーム処理が実行された場合のみlastDistanceを更新
                    lastTouchDistance = currentDistance;
                    updateURLHash();
                }
                
                lastTouchCenter = currentCenter;
                
                // 移動中の中央座標表示
                showCenterTooltip();
                return;
            }

            // 1本指移動
            if (event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0];
                mouse_pos.x = touch.clientX;
                mouse_pos.y = touch.clientY;
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                
                // 移動中の中央座標表示
                showCenterTooltip();
            }
        }, { passive: false });
        map.addEventListener('touchend', function(event) {
            prev_mouse_pos = null;
            lastTouchCenter = null;
            lastTouchDistance = null;
            hideCenterTooltip();
            updateURLHash();
        });
        map.addEventListener('mousemove', function(event) {
            mouse_pos.x = event.clientX;
            mouse_pos.y = event.clientY;
            
            // マウス移動時に座標表示更新
            updatePositionDisplay();
            
            if (event.buttons === 1) {
                if (prev_mouse_pos === null) {
                    prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                }
                pos.x += (mouse_pos.x - prev_mouse_pos.x);
                pos.y += (mouse_pos.y - prev_mouse_pos.y);
                prev_mouse_pos = { x: mouse_pos.x, y: mouse_pos.y };
                
                // ドラッグ移動中の中央座標表示
                showCenterTooltip();
            } else {
                if (prev_mouse_pos !== null) {
                    // ドラッグ終了時にURL更新
                    updateURLHash();
                }
                prev_mouse_pos = null;
                hideCenterTooltip();
            }
        });

        // ズームボタン
        document.getElementById('zoom-in').addEventListener('click', function() {
            const prev_zoom = zoom;
            const centerScreenX = 0;
            const centerScreenY = 0;
            const mapX = (centerScreenX - pos.x) / prev_zoom;
            const mapY = (centerScreenY - pos.y) / prev_zoom;
            zoom += 0.1;
            if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
            pos.x = centerScreenX - mapX * zoom;
            pos.y = centerScreenY - mapY * zoom;
            updateURLHash();
        });
        document.getElementById('zoom-out').addEventListener('click', function() {
            const prev_zoom = zoom;
            const centerScreenX = 0;
            const centerScreenY = 0;
            const mapX = (centerScreenX - pos.x) / prev_zoom;
            const mapY = (centerScreenY - pos.y) / prev_zoom;
            zoom -= 0.1;
            if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
            pos.x = centerScreenX - mapX * zoom;
            pos.y = centerScreenY - mapY * zoom;
            updateURLHash();
        });
        // ランキングモーダル
        const rankingButton = document.getElementById('ranking-button');
        const rankingModal = document.getElementById('ranking');
        rankingButton.addEventListener('click', function() {
            rankingModal.classList.toggle('show');
            // 
            if (this.abortController) {
                this.abortController.abort();
            }
            this.abortController = new AbortController();
            const rankingList = document.getElementById('ranking-list');
            rankingList.innerHTML = '';
            fetch('/data/place_ranking.txt', { signal: this.abortController.signal })
                .then(res => res.text())
                .then(data => {
                    const players = data.split('\n').filter(line => line.split(',').length === 4).map(line => {
                        const [uuid, name, totalPlace, places] = line.split(',');
                        return { uuid, name, score: parseInt(totalPlace), scoreHistory: places.split('|').map(p => parseInt(p)) };
                    }).filter(p => p.uuid && p.name);
                    players.sort((a, b) => b.score - a.score);
                    players.forEach((player, index) => {
                        const rankEl = document.createElement('div');
                        rankEl.className = 'rank';
                        if (index < 3) {
                            const crown = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            crown.setAttribute('viewBox', '0 -960 960 960');
                            crown.classList.add('crown');
                            crown.innerHTML = '<path d="M200-160v-80h560v80H200Zm0-140-51-321q-2 0-4.5.5t-4.5.5q-25 0-42.5-17.5T80-680q0-25 17.5-42.5T140-740q25 0 42.5 17.5T200-680q0 7-1.5 13t-3.5 11l125 56 125-171q-11-8-18-21t-7-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820q0 15-7 28t-18 21l125 171 125-56q-2-5-3.5-11t-1.5-13q0-25 17.5-42.5T820-740q25 0 42.5 17.5T880-680q0 25-17.5 42.5T820-620q-2 0-4.5-.5t-4.5-.5l-51 321H200Z"/>';
                            rankEl.appendChild(crown);
                        }
                        const headimg = document.createElement('img');
                        headimg.className = 'headimg';
                        headimg.src = `http://mcskinapi.siyukatu.com/heads/${player.uuid}`;
                        rankEl.appendChild(headimg);
                        const details = document.createElement('div');
                        details.className = 'details';
                        const nameEl = document.createElement('h3');
                        nameEl.innerText = player.name;
                        details.appendChild(nameEl);
                        const graph = document.createElement('div');
                        graph.className = 'graph';
                        const maxScore = Math.max(...player.scoreHistory);
                        for (let i = 0; i < 14; i++) {
                            const score = player.scoreHistory[i] || 0;
                            const stick = document.createElement('div');
                            stick.className = 'stick';
                            const stickHeight = (score / maxScore) * 100;
                            stick.style.height = `${stickHeight}%`;
                            graph.appendChild(stick);
                        }
                        details.appendChild(graph);
                        rankEl.appendChild(details);
                        rankingList.appendChild(rankEl);
                    });
                }).catch(err => {
                    if (err.name === 'AbortError') {
                        // abort時は無視
                    } else {
                        console.error('Failed to load ranking:', err);
                    }
                });
        });
        rankingModal.addEventListener('click', function(event) {
            if (event.target === rankingModal) {
                rankingModal.classList.remove('show');
            }
        });
        
        // ハッシュ変更の検知
        window.addEventListener('hashchange', function() {
            loadFromURLHash();
        });
        
        // 初期化時にURLハッシュから状態を復元
        loadFromURLHash();
        
        // プレイヤーデータの定期取得を開始
        fetchPlayerData(); // 初回取得
        setInterval(fetchPlayerData, 1000); // 毎秒取得
        
        // 初回起動
        update();
    </script>
</body>
</html>